# Meeting Notes

not using openocd is a problem, cant assume if it works but or1ksim that it is going to work with openOCD

think about stripping down openOCD to only contain functionalities for gecko5education.

DDD quite nice graphical interface, it is cross platform ? openOCD for sure is.

maybe there's a plugin for VS Code that does that. specifically for GDB. likely that there's one already

START WITH dummy debug controler that answers dummy values. dummy state machine for memory reads for instance

GDB for or1200 should work fine decompiling or1300 instructions.


TODO

1/ 
get the setup for last semester project running with GDB. last years student used a CLI to send instructions to the JTAG interface, now needs to use GDB.
- try and understand the way openOCD transforms GDB commands into JTAG commands

another possibility: "rewriting" openOCD to understand GDB protocol and translate it into JTAG

GDB is absolutely given 


- last years semester project setup working
- compare the packets when using GDB vs telnet. hopefully some of the work can be done only using the ipcore and memory access
- moving to gdb
- write a dummy debug controler

dummy controler that supports a very barebones software

length of two chains // length of data register should be hardcoded in openOCD driver directly. usually stored in """BSD files""" ???

---------------

convert_32 program takes in the .elf file and generates the CMEM file.
CMEM file contains read-only and read-write sections writen in ACSII, because of limitation of the serial connection

utility would not be needed anymore if we move to JTAG for uploading files.

---------------

2/ look for frontend alternative (DDD) ? maybe one for vs code.

# Work Done

## Getting last years semester project running

Re installed cs476 toolchain and oss-cad-suite to synthesize design.
Synthesized and uploaded VP to fpga.
Can either connect through telnet to send custom jtag commands to FPGA or use the provided program

### Opening OpenOCD server

```bash
openocd -f config.cfg
```

### Communicating with FPGA

Writing to memory
```bash
jules@jules-ubuntu:............$ ./jtag_interface -w -addr 0x000100 -bs 4 -s 10
Connected to OpenOCD Tcl server at 127.0.0.1:4444
Transaction setup complete with address 0x000100 and burst size 3
Enter a 32-bit hex value (without 0x prefix): deadbeef
Enter a 32-bit hex value (without 0x prefix): b00b5111
Enter a 32-bit hex value (without 0x prefix): deadbeef
Enter a 32-bit hex value (without 0x prefix): deadbeef
Enter a 32-bit hex value (without 0x prefix): deadbeef
Enter a 32-bit hex value (without 0x prefix): deadbeef
Enter a 32-bit hex value (without 0x prefix): eeeeeeee
Enter a 32-bit hex value (without 0x prefix): eeeeeeee
Enter a 32-bit hex value (without 0x prefix): ffffffff
Enter a 32-bit hex value (without 0x prefix): eeeeeeee
```

Reading from memory
```bash
jules@jules-ubuntu:..........$ ./jtag_interface -r -addr 0x000100 -bs 4 -s 10
Connected to OpenOCD Tcl server at 127.0.0.1:4444
Transaction setup complete with address 0x000100 and burst size 3
0x00000100 : 	0xdeadbeef
0x00000104 : 	0xb00b5111
0x00000108 : 	0xdeadbeef
0x0000010c : 	0xdeadbeef
0x00000110 : 	0xdeadbeef
0x00000114 : 	0xdeadbeef
0x00000118 : 	0xeeeeeeee
0x0000011c : 	0xeeeeeeee
0x00000120 : 	0xffffffff
0x00000124 : 	0xeeeeeeee
```

MVP component: `jtag_support` 
`jtag_interface.v` interfaces the lattice PFGA (JTAGG module, its builtin) and the `jtag_support` module
`jtag_support.v` interfaces JTAG (through ipcore and pingpongbuffer) and access to internal components (dma)

## Problem

Problem: using telnet to connect to openOCD does not make use of the GDB remote serial protocol of course

## OpenOCD docs

TODO
- Find how GDB RSP commands are translated into JTAG commands.
- Find how JTAG commands are processed physically by the JTAGG impl of FPGA

JTAG commands include
```bash
irscan <tap_name> <instruction> # readwrite to jtag instruction register
drscan <tap_name> <size> <data> # readwrite to jtag data register
pathmove <tap_state_name>       # move tap controler to said state
runtest <nb_cycles>             # run N cycles of TAP controler FSM
```

## OpenOCD notes


### DC Module list

The debug controler contains four modules. The debug controler dispatches incoming instructions to one of these modules, for this reason all DR scans are always preceeded by a first DR scan to choose what module we want to communicate with.

```c
/* Definitions for the top-level debug unit.  This really just consists
 * of a single register, used to select the active debug module ("chain").
 */
#define DBG_MODULE_SELECT_REG_SIZE	2
#define DBG_MAX_MODULES			4

#define DC_NONE				-1
#define DC_WISHBONE			0
#define DC_CPU0				1
#define DC_CPU1				2
#define DC_JSP				3
```

### Choose module (example of DR scan)


A generic DR scan looks like this.
- Instanciation of `scan_field` containing the information of the scan: size of DR, in and out value. In value goes in the chip through TDI, out value goes out of the chip through TDO. 
- Call to `jtag_add_dr_scan` which queues the scan info.
- Call to `jtag_execute_queue` empties the queue and executes all queued DR scans. Notice how `scan_field` will be out of scope when the method returns, which prooves that the scan info is no longer in use

```c
// src/target/openrisc/or1k_du_adv.c
uint8_t data = chain | (1 << DBG_MODULE_SELECT_REG_SIZE);

struct scan_field field;

field.num_bits = (DBG_MODULE_SELECT_REG_SIZE + 1);
field.out_value = &data; // data written to DR
field.in_value = NULL; // buffer to read from DR
jtag_add_dr_scan(jtag_info->tap, 1, &field, TAP_IDLE); // queue DR scan

int retval = jtag_execute_queue(); // dequeue and execute all queued DR scans
if (retval != ERROR_OK)
    return retval;

// Scan done. Here there's usually code that updates the information stored in the driver
// to keep it up to date with the TAP/DC state.
```

`field.out_value` is a pointer to the data being written to the DR. Here it is a 1xx bit to indicate we want to choose one of the 4 modules.
`field.in_value` usually is an address to a buffer since we're reading data from the chip. Or NULL if we only want to write. Here the sample code is for selecting a module so there's no data to read.



## Memory read

In order to perform a memory read:
- call to `adbg_select_module`, one **dr scan** to select wishbone bus module
- call to `adbg_wb_burst_read` for each single burst read.
    - call to `adbg_burst_command` which sends a **DR scan** containing info about the incoming burst read: address and size.
    - finally, the actual **DR scan** that reads data from memory location

Total number of DR scans per memory read: `1 + 2 * <burst_nb>`

```c
static int or1k_adv_jtag_read_memory(struct or1k_jtag *jtag_info,
			    uint32_t addr, uint32_t size, int count, uint8_t *buffer)
{
	LOG_DEBUG("Reading WB%" PRIu32 " at 0x%08" PRIx32, size * 8, addr);

    // initialization code
    //...........

	retval = adbg_select_module(jtag_info, DC_WISHBONE); // Select BUS module
	if (retval != ERROR_OK)
		return retval;

	int block_count_left = count;
	uint32_t block_count_address = addr;
	uint8_t *block_count_buffer = buffer;

	while (block_count_left) {

		int blocks_this_round = (block_count_left > MAX_BURST_SIZE) ?
			MAX_BURST_SIZE : block_count_left;

		retval = adbg_wb_burst_read(jtag_info, size, blocks_this_round,
					    block_count_address, block_count_buffer); // perform single burst read, write to buffer
		if (retval != ERROR_OK)
			return retval;

		block_count_left -= blocks_this_round;
		block_count_address += size * MAX_BURST_SIZE;
		block_count_buffer += size * MAX_BURST_SIZE;
	}

    // correct endianness
    //........

	return ERROR_OK;
}

static int adbg_wb_burst_read(struct or1k_jtag *jtag_info, int size,
			      int count, uint32_t start_address, uint8_t *data)
{
	int retry_full_crc = 0;
	int retry_full_busy = 0;
	int retval;
	uint8_t opcode;

	LOG_DEBUG("Doing burst read, word size %d, word count %d, start address 0x%08" PRIx32,
		  size, count, start_address);

	/* Select the appropriate opcode */
	//...........

	int total_size_bytes = count * size;
	struct scan_field field;
	uint8_t *in_buffer = malloc(total_size_bytes + CRC_LEN + STATUS_BYTES);

retry_read_full:

	/* Send the BURST READ command, returns TAP to idle state */
	retval = adbg_burst_command(jtag_info, opcode, start_address, count);
	if (retval != ERROR_OK)
		goto out;

	field.num_bits = (total_size_bytes + CRC_LEN + STATUS_BYTES) * 8;
	field.out_value = NULL;
	field.in_value = in_buffer;

	jtag_add_dr_scan(jtag_info->tap, 1, &field, TAP_IDLE);

	retval = jtag_execute_queue();
	if (retval != ERROR_OK)
		goto out;

	// check status bit
    // .....................

	buffer_shr(in_buffer, total_size_bytes + CRC_LEN + STATUS_BYTES, shift);

    // check for crc error
	//...................

    // read and process error register
    //...........

out:
	free(in_buffer);

	return retval;
}
```

