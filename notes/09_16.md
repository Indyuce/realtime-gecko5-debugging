# Meeting Notes

signals already existing for the cpu-debug controler interface. not tested. they were already a thing in the or1300 vp for the course but they were never tested when implemented in the VP.

wishbone interface = bus interface. not going to use, no wishbone interface in the virtual prototype. wishbone = bus specification. not exactly the one from the vp but almost the same.

look for name or standard for cpu-debug controler interface?

custom instructions, atomic instructions, not in the or1300 VP. apart from that, anything else should be the same.

LOOK FOR GDB SERVER PACKAGES explanation, gdb-openocd interface

# Work Done

## or1ksim installation

Installed the or1ksim from the website. Had an initial error because my computer was missing a gcc compiler. Installing toolchain from cs473 fixed that issue.

Simulator can be ran using. Using `-f` allows to directly enter a command line interface
```bash
or1k-self-sim -f <path_to_config_file>
```
Config file provides config options including options to debug with GDB.

First thought: does not use openOCD, because openOCD is actually the one running the server. Here or1ksim wraps the server that wouldve been opened by openOCD.

## Running hello world on simulator

### Install latest OR1K toolchain

I first tried installing it through the Ubuntu package manager
```bash
sudo apt install or1k-elf-gcc
```
This is only the compiler, it does not include the standard C libraries and compiler utilities. The easiest way is to use a prebuilt toolchain. In CS473 I think we built it ourselves by downloading the source and compiling it locally.

Go to [public repo for releases of or1k toolchains](https://github.com/stffrdhrn/or1k-toolchain-build/releases). Latest is `OpenRISC GCC Toolchain 15.1.0-20250621`. Go for bare metal (= no OS on the chip) download `or1k-elf-15.1.0-20250621.tar.xz`.

Extract file and add the `<extracted_folder_path>/or1k-elf/bin` folder path to your CMD path using. Can be added to `.bashrc` to apply to all terminals of current user.
```bash
export PATH=<extract_folder_path>/or1k-self/bin/:$PATH
``` 

### Compiling basic program

Basic hello world program (`hello_world.c`)
```c
#include <stdio.h>

int main() {
    printf("Hello OR1200!\n");
    return 0;
}
```

Compile program using (make sure the CLI has the $PATH env var up to date with the toolchain commands):
```bash
or1k-elf-gcc -o hello_world.elf hello_world.c
```

ELF file `hello_world.elf` contains the binaries for the built program.

## Running program on simulator

```bash
jules@jules-ubuntu:~/git/realtime_debugging_gecko5education/src/or1k_programs$ or1k-elf-sim hello_world.elf -f sim.cfg 
............
Program Header: PT_LOAD, vaddr: 0x00000000, paddr: 0x0 offset: 0x00002000, filesz: 0x0000519c, memsz: 0x0000519c
ERR: 8-bit program load out of memory area: 00000000
ERR: 8-bit program load out of memory area: 00000001
ERR: 8-bit program load out of memory area: 00000002
ERR: 8-bit program load out of memory area: 00000003
ERR: 8-bit program load out of memory area: 00000004
..................
```

Need to give non-null RAM size to simulator either using `or1k-elf-sim -m 8M .....` or by providing a `sim.cfg` file. The default `sim.cfg` file usually has a non zero memory size.

```bash
jules@jules-ubuntu$ or1k-elf-sim hello_world.elf -f sim.cfg 
.......
Program Header: PT_LOAD, vaddr: 0x00000000, paddr: 0x0 offset: 0x00002000, filesz: 0x000069b4, memsz: 0x000069b4
Program Header: PT_LOAD, vaddr: 0x000089b4, paddr: 0x89b4 offset: 0x000089b4, filesz: 0x000006b4, memsz: 0x00000b88
Hello OR1200!
```

Program running fine

## Connecting to GDB

### Howto

Running GDB throwed an error, my computer was missing a Python 3.11 lib. Latest Ubuntu repos only contain Python 3.12 so need to use unofficial repo `deadsnakes`.
```bash
sudo apt update
sudo apt install software-properties-common
sudo add-apt-repository ppa:deadsnakes/ppa
sudo apt update
sudo apt install python3.11 python3.11-dev
```

Run simulator (server-side RSP) using:
```bash
or1k-elf-sim hello_world.elf -f sim.cfg
```

Only then (server needs to be up and listening) run GDB (RSP client) using:
```bash
or1k-elf-gdb hello_world.elf --eval-command='target remote localhost:3333'
```

### Docs

TWO THINGS [link](https://www.embecosm.com/appnotes/ean2/html/ch03s03.html)

> Previously, the OpenRISC 1000 port of GDB only worked through the JTAG port of the processor, which had to incorporate a working debug unit. The connection to the target could either be through the parallel port to physical hardware connected via a JP1 header, or via TCP/IP to a remote target. Communication to the remote target was via the proprietary OpenRISC 1000 Remote JTAG Protocol.
> [Important]	Important
> The OpenRISC 1000 Remote JTAG Protocol is still supported for backward compatibility, but now deprecated. All remote connection should be through the GDB Remote Serial Protocol. 

**OpenRISC 1000 Remote JTAG Protocol** or **GDB Remote Serial Protocol**.

> A remote target should implement the server side of either or both of the GDB Remote Serial Protocol and the OpenRISC 1000 Remote JTAG Protocol. The target may be the Or1ksim architectural simulator or a driver for physical hardware, such as the USB JTAG connector made by ORSoC AB. 

Driver for physical hardware = OpenOCD.

>There are two variants of the Debug Unit for the OpenRISC 1000, with slightly different JTAG interfaces.
>- The original JTAG interface was created as part of the OpenRISC SoC project, ORPSoC [4]. It provides three scan chains: one to access all the Special Purpose Registers, one to access external memory and one providing control of the CPU. The control scan chain can reset, stall or trace the processor.
>- A new JTAG interface was provided by Igor Mohor in 2004 [5]. It provides the same access to Special Purpose Registers and external memory, but offers a simpler control interface offering only the ability to stall or reset the processor.

Means we have to choose what debug unit to add to the or1k3. Or there might only be one supported by OpenOCD, so check this as well.

or1ksim already implements the GDB RSP protocol so stacking up openOCD and or1ksim makes no sense.

## GDB RSP protocol

### Using wireshark

Use `lo` (loopback mode), apps running on 127.0.0.1 so it does not use the wifi card.
![](images/wireshark_ack.png)

Here payload is 1 byte long, `U+2b` unicode char for `+`. `+` is the standard payload for an ack indicating that the checksum of received packet is valid.

### Packet list

Packet for [GDB RSP](https://sourceware.org/gdb/current/onlinedocs/gdb.html/Packets.html)

Some examples:
- `$m100,10` reads at address x100 with length 10 bytes
- `g` read all registers
- `pN` read register N
- `PN=....` write register N  
- `i [addr,[nn]]` step one cycle, if provided at address, if provided n times

Multiple existing GDB UI/front ends [here](https://sourceware.org/gdb/wiki/GDB%20Front%20Ends)