# Meeting Notes

use one of the two custom OPCODEs from JTAGG primitive, we will not be creating a different TAP controler for the CPU/emulating the JTAGG controler in verilog => need to interface JTAGG with adv_debug_if directly

#Â Work Done

## iverilog simulation

objective: first get a simulation working using the `JTAGG.v` verilog simulation provided by tom vebeure
after this, we can simulate the interface with `adv_debug_if`

### send raw jtag commands

Since we are testing the raw JTAGG primitive, we need to write verilog tasks and send RAW jtag commands bit-by-bit
objective: write tasks to send IR and DR scans
```verilog
task send_ir(input [7:0] ir_value);
task send_dr(input [63:0] dr_value, input integer dr_len);
```

then we can do an ir scan with IDCODE `0x38` using
```verilog
send_ir(8'h38);
```

Recall JTAG TAP FSM
![](images/tap-controller-fsm.png)

simulations compiled using icarus verilog
```bash
iverilog -o testbench tb_select_module.v  \
   jtag_tap.v JTAGG.v \
   ../verilog/jtag_if.v ./../../adv_debug_if/verilog/*.v -I./../../adv_debug_if/verilog
echo "tb compiled"
./testbench
echo "tb ran"
```

using GTKWave to check simulation results.

Implemented those functions using ChatGPT. fixed the IR len to 8 and managed to get the right IDCODE to show up in the `ir_shadow_reg` of the JTAG TAP controler as seen below. recall custom IDCODEs are `0x32` and `0x38`.

![](images/gtk_irscan.png)

### select adbg module

reverse engineering source code of openOCD method for selecting one of the debug controler modules:
```c
/* Selects one of the modules in the debug unit
 * (e.g. wishbone unit, CPU0, etc.)
 */
static int adbg_select_module(struct or1k_jtag *jtag_info, int chain)
{
	if (jtag_info->or1k_jtag_module_selected == chain)
		return ERROR_OK;

	/* MSB of the data out must be set to 1, indicating a module
	 * select command
	 */
	uint8_t data = chain | (1 << DBG_MODULE_SELECT_REG_SIZE);

	LOG_DEBUG("Select module: %s", chain_name[chain]);

	struct scan_field field;

	field.num_bits = (DBG_MODULE_SELECT_REG_SIZE + 1);
	field.out_value = &data;
	field.in_value = NULL;
	jtag_add_dr_scan(jtag_info->tap, 1, &field, TAP_IDLE);

	int retval = jtag_execute_queue();
	if (retval != ERROR_OK)
		return retval;

	jtag_info->or1k_jtag_module_selected = chain;

	return ERROR_OK;
}
```

```c
uint8_t data = chain | (1 << DBG_MODULE_SELECT_REG_SIZE);
```

argument `chain` is one of the following
```c
#define DC_WISHBONE			0
#define DC_CPU0				1
#define DC_CPU1				2
#define DC_JSP				3
```

the corresponding verilog code in the top level of the adbg controler, where `DBG_TOP_MODULE_DATA_LEN` is 53
```verilog
// Registers
reg [`DBG_TOP_MODULE_DATA_LEN-1:0] input_shift_reg;  // 1 bit sel/cmd, 4 bit opcode, 32 bit address, 16 bit length = 53 bits

//.............

///////////////////////////////////////
// Combinatorial assignments

assign select_cmd = input_shift_reg[52];
assign module_id_in = input_shift_reg[51:50];

//////////////////////////////////////////////////////////
// Module select register and select signals

always @ (posedge tck_i or posedge rst_i)
begin
  if (rst_i)
    module_id_reg <= 2'b0;
  else if(debug_select_i && select_cmd && update_dr_i && !select_inhibit)       // Chain select
    module_id_reg <= module_id_in;
end
```

to select wishbone module we can use a DR scan with a data of:
```c
uint8_t data = 0b100;
```

equivalent to raw JTAG bit-level command:
```verilog
send_dr(53'b100);
```

#### first problem

i set `debug_select_i` to `JRTI1` (high on run/time/idle when 0x32 is in IR) but `debug_select_i` needs to be 1 for as long as 0x32 is selected, not only in run/test/idle.......

why does JTAGG not provide references to ALL internal TAP signals?????????????????

fixed by implementing two new signals to properly interface signals provided by JTAGG. `SEL1` should be high for as long as `0x32` is found in IR.
```verilog
/*
* First interface problem:
* We need a signal high when 0x32 is loaded
* in IR. This is not exactly that but sufficient,
* most important is in SHIFT IR/DR.
*/ 
assign s_SEL1 = s_JRTI1 | s_JCE1;
```


second signal is `s_CAPTURE1`. this one is accurate, `JCE1` is high on capture/shift so by applying `&& !JSHIFT` we can filter out when the TAP is shifting. chatGPT pretends it is not a necessary transformation.. ?
```verilog
/*
* Second interface problem:
* JTAGG provides JCE1 (clock enable 1) which is
* high when TAP is either in CAPTURE or SHIFT and
* when 0x32 is in IR. we only need when CAPTURE is high,
* not shift.
*/
assign s_CAPTURE1 = s_JCE1 && !s_JSHIFT;
```

#### problem 1

not a perfect implementation of `debug_select_i` let the image speak for itself, there are literally 2 gaps where `debug_select_i` goes low because of intermediary TAP states not covered by output signals. maybe its possible to improve the implementation of that signal but DR scans work atm

![](images/gtk_delay_pb.png)

#### problem 2

code used for the previous image
```verilog
send_dr(4'b0110, 4); // select wishbone module
```

according to openOCD code for selecting adbg module:
```c
struct scan_field field;

field.num_bits = (DBG_MODULE_SELECT_REG_SIZE + 1);
field.out_value = &data;
field.in_value = NULL;
jtag_add_dr_scan(jtag_info->tap, 1, &field, TAP_IDLE);
```

looks like it does not take into account that necessary 1 clock delay. the number of bits is `DBG_MODULE_SELECT_REG_SIZE + 1 = 2 + 1`. one bit for the select/submodule command and 2 bits to indicate the module. there are 4 modules so only 2 bits are required. there is no such "extra bit for padding or timing constraints" or whatever

## Conclusion

using simulations allowed me to fix up the interfacing with signals provided by Lattice JTAGG primitive

# TODO

reverse engineer openOCD. does it take into account that delay slot or are we going to run into issues? most likely not due to argument given above.

what solution to choose
- SOFTWARE SOLUTION: edit the whole or1k driver and naturally add a padding 0 to all DR scans.
- HARDWARE SOLUTION (sounds less stupid): latch all signals of JTAGG except TDI.
to me, hardware makes more sense. openOCD works on existing or1k, we should fix up Lattice JTAGG primitive and have it match JTAG standards, instead of patching up openOCD.

get out of simulations and start working again on OpenOCD: add debug code to return the selected adbg module to TDO so that we can make sure communication works with openOCD.
