 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% EPFL report package, main thesis file
% Goal: provide formatting for theses and project reports
% Author: Mathias Payer <mathias.payer@epfl.ch>
%
% This work may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[a4paper,11pt,oneside]{report}
% Options: 
% MScThesis, BScThesis, MScProject, BScProject - Type of project.
% lablogo - Includes the logo of the lab in the title page.
% condensed - Removes the page breaks between chapters, treating each chapter 
%             as a level-0 section.
\usepackage[lablogo]{EPFLreport}
\usepackage{xspace}
\usepackage{caption} % for table captions
\usepackage{subcaption} % for subfigures
\usepackage{tikz} % for drawing rectangles, for pipelines for eg
\usepackage{amsmath} % for \text in math mode
\usetikzlibrary{positioning} % Needed for 'right of' syntax
\usetikzlibrary{calc} % needed for multiple arrows per rect
\usepackage{array} % test for justifying tables/arrays
\usepackage{pifont} % test for math icons
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}
%\usepackage{booktabs} % for better tables
% Bibliography settings
\usepackage[
  backend=biber,
  style=numeric-comp,
  hyperref=true,
  %style=numeric,
  %sorting=ydnt,
  defernumbers=true,
  maxbibnames=99,
]{biblatex}
\addbibresource{thesis.bib}
\setcounter{biburllcpenalty}{7000}
\setcounter{biburlucpenalty}{8000}

% change verbatim blocks to have gray background
\usepackage{fancyvrb} % Pour des verbatims améliorés
\usepackage{xcolor}    % Pour les couleurs

\DefineVerbatimEnvironment{CodeVerbatim}{Verbatim}
  {frame=single, rulecolor=\color{black}}

\title{Real-time debugging of a soft-core OpenRISC CPU}
\author{Jules Peyrat}
\supervisor{Dr. Theo Ties Jan Kluter}
\adviser{Dr. Paolo Ienne}

\newcommand{\sysname}{FooSystem\xspace}

\begin{document}
\maketitle


%%%%%%%%%%%%%%%%%%%%%%
\acknowledgements{
%%%%%%%%%%%%%%%%%%%%%%

I sincerely thank my project supervisor, Dr. Theo Kluter, for allowing me to work on this semester project within the LAP laboratory. I found great interest in this project, and I believe it will greatly support my academic and professional development.

}

\makeacks

\begin{abstract}

The CS-473 course at EPFL uses the Gecko5Education board featuring a soft-core OpenRISC CPU for teaching system-level programming. However, the existing debugging interface designed for the OR1200 processor is not fully compatible with the virtual prototype used in this course, preventing real-time debugging and step-by-step execution.

This project aims at adapting the Advanced Debug Interface (ADI) to enable GDB-based debugging for the CS-473 CPU. On the software side, we implement a new OpenOCD driver to communicate with the Lattice ECP5 FPGA's native JTAGG hardware primitive, which differs from the soft-core TAP controllers typically used with the ADI. On the hardware side, we refactor the Bus Interface Unit (BIU) of the Wishbone module to interface with the virtual prototype's system bus, enabling memory read and write operations. Adapting the CPU module's BIU and connecting the CPU stall control signals is also required to access the register file, and perform step-by-step execution and breakpoint management.



%The abstract serves as an executive summary of your project. Your abstract should cover at least the following topics, 1-2 sentences for each: what area you are in, the problem you focus on, why existing work is insufficient, what the high-level intuition of your work is, maybe a neat design or implementation decision, and key results of your evaluation.

\end{abstract}

\maketoc

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction}
%%%%%%%%%%%%%%%%%%%%%%

The CS473 course at EPFL relies on a soft-core CPU virtual prototype of the OpenRISC 1000 CPU specifications, synthesized and executed on a Lattice ECP5 FPGA, enabling students to experiment with low-level architectural concepts in a realistic environment.

The first, public, Verilog implementation of the OpenRISC 1000 architecture—or \textit{or1k}— is referred to as the \textit{OR1200} CPU \cite{or1200_src}, for which debugging interfaces are already available \cite{adv_debug_sys} \cite{soc_debug_sys}. These interfaces support integration with the GNU Debugger (GDB) \cite{gdb}, allowing real-time debugging features such as CPU state inspection, step-by-step execution, memory reads and writes, and breakpoint management. Such capabilities are essential for efficient development, testing, and educational use.

However, the CPU used in CS-473 has several architectural differences from the OR1200 core. As a result, the existing OpenRISC debugging infrastructure cannot be used without modification.

\section{Project Overview}

The objective of this project is to enable real-time debugging capabilities for the soft-core CPU used in the CS-473 course by adapting an existing OR1200-compatible debug interface \cite{adv_debug_sys}, which will be referred to as the \textit{Advanced Debug Interface}, or ADI.

The core of this work consists of refactoring the ADI originally developed for the OR1200 processor. In order to allow for memory access through GDB, the memory submodule of the ADI must be adapted to the bus architecture employed on the virtual prototype (VP). In order to allow for register access, program breakpoints, and step-by-step execution, the CPU submodule of the ADI must be refactored.

On the hardware side, this project leverages the native JTAG primitive provided by the Lattice ECP5 FPGA. Notably, this is the JTAG terminal used to reconfigure the FPGA gates when uploading a program onto the virtual prototype. The debug interface used in this project is designed to work with soft-core JTAG TAP controllers.

On the software side, OpenOCD only supports a subset of JTAG TAP controllers, while the native JTAG primitive of our Lattice FPGA is not one of them. Consequently, OpenOCD needs a new driver to communicate with the JTAG terminal of our Lattice FPGA.

The full code of the virtual prototype, testbenches and additional documentation can be found in the following \href{https://github.com/Indyuce/realtime-gecko5-debugging}{\textbf{GitHub repository}}. The code of the OpenOCD fork used in this project can be found in \href{https://github.com/Indyuce/openocd-gecko5}{\textbf{this repository}}.

\section{Report Overview}

The first chapter introduces important background on software used in this project, such as OpenOCD, which will be used as a hardware-software bridge to communicate with the ADI. It also presents the FPGA used in this project, as well as the JTAG standard, which is used to communicate with the board.

The second chapter provides key technical implementation details about the OpenOCD driver used to communicate with the debug controller, as well as the Verilog implementation of the debug controller itself.

The third chapter presents a few testbenches to validate several parts of the debug controller, and results of real-time tests executed on the synthesized design.

%The introduction is a longer writeup that gently eases the reader into your
%thesis~\cite{dinesh20oakland}. Use the first paragraph to discuss the setting.
%In the second paragraph you can introduce the main challenge that you see.
%The third paragraph lists why related work is insufficient.
%The fourth and fifth paragraphs discuss your approach and why it is needed.
%The sixth paragraph will introduce your thesis statement. Think how you can
%distill the essence of your thesis into a single sentence.
%The seventh paragraph will highlight some of your results
%The eights paragraph discusses your core contribution.

%This section is usually 3-5 pages.


%%%%%%%%%%%%%%%%
\chapter{Background}
%%%%%%%%%%%%%%%%

\section{GDB}

The \textit{GNU Debugger} (GDB) \cite{gdb} is a powerful and flexible debugging tool widely used in embedded systems development. In real-time debugging scenarios, GDB provides developers with the ability to inspect memory, analyze register states, and control program execution. When connected through a suitable debug interface—such as a JTAG-based bridge and a custom on-chip debug module—GDB enables non-intrusive, step-by-step investigation of running code while minimizing disruption to program execution.

Beyond real-time debugging, GDB is also a convenient tool for uploading programs directly to the FPGA hosting the soft-core processor. When paired with an appropriate debug stub or on-chip bootloader, GDB is able to load compiled binaries into the processor’s memory space through the same physical interface used for inspection and control.

\section{OpenOCD}

OpenOCD (Open On-Chip Debugger) \cite{openocd} is an open-source software tool designed to provide debugging, programming, and boundary-scan functionalities for embedded systems. It acts as a bridge between software development tools running on a host computer and target hardware. OpenOCD supports a wide range of processors, architectures and hardware interfaces (including JTAG).

In the context of this project, OpenOCD is used as a backend debug server interfacing with the FPGA through a JTAG connection. On one hand, it provides a Telnet server that allows direct interaction with the JTAG interface by issuing low-level debug commands (\textit{raw} bit-level DR/IR scans). This mode is particularly useful for testing FPGA debug logic. On the other hand, OpenOCD exposes a GDB Remote Serial Protocol (RSP) server, enabling a direct connection between GDB and the target CPU. Through this interface, GDB can communicate with both the processor core and the system bus, allowing real-time debugging features such as register inspection, memory access, execution control, and breakpoint handling.

\section{OpenRISC}

OpenRISC is an open-source project aimed at developing a free and fully documented RISC instruction set architecture (ISA) and corresponding processor cores. The first publicly available implementation of the OpenRISC 1000 architecture is known as the OR1200, and features a complete, 5-stage pipelined, RISC-based processor with a debugging interface.

In this project, we work with a CPU that is closely based on the OR1200 core but introduces several adaptations to fit the virtual prototype platform used in the CS-473 course. Notably, the system bus architecture differs from the original OpenRISC Wishbone bus.

Note that the GDB build used in this work is the custom build provided in the \verb|or1k-elf| toolchain \cite{or1k_toolchain}.

\section{The JTAG Standard}

%\subsection{The JTAG Standard}

%interface to perform boundary scans

JTAG (\textit{Join Action Test Group}) is a hardware communication protocol mainly used for debugging system-on-chips in real-time. The JTAG bus is composed of four synchronous signals and an optional asynchronous active-low reset signal. The four synchronous signals are presented in figure \ref{fig:jtag_signals}.

\begin{figure}
    \centering

\begin{tabular}{|c|c|p{7cm}|}
\hline
\textbf{Signal} & \textbf{Name} & \textbf{Description} \\
\hline
\textbf{TCK} & Test Clock & TAP clock signal \\
\hline
\textbf{TMS} & Test Mode Select & Used to navigate through the TAP FSM \\
\hline
\textbf{TDI} & Test Data In & Data input bitline \\
\hline
\textbf{TDO} & Test Data Out & Data output bitline \\
\hline
\end{tabular}

    
    \caption{JTAG Synchronous Signals}
    \label{fig:jtag_signals}
\end{figure}

%\subsection{JTAG TAP Controllers}

TAP (\textit{Test Access Port}) controllers are hardware components that software JTAG drivers/bridges communicate with. TAP controllers implement the JTAG TAP finite state machine presented in figure \ref{fig:jtag_fsm}.

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{assets/jtag_fsm.png}
    \caption{JTAG TAP Finite State Machine}
    \label{fig:jtag_fsm}
\end{figure}

JTAG TAPs all have one internal register called the \textbf{instruction register}. Its size varies with the number of instructions the TAP controller supports. In order for the computer to send payload data (test vector, command...) to the TAP controller, it first needs to load the correct instruction operation code inside the instruction register through an \textbf{IR-scan}. The \textit{opcode} stored inside the IR determines the data register exposed to the computer during subsequent \textbf{DR-scans}.

TAPs all share at least two instructions: \textbf{IDCODE} and \textbf{BYPASS}. When \textbf{BYPASS} is loaded inside the IR, the TDI and TDO lines are connected. This is useful for selectively disabling some TAPs when multiple TAPs are connected in series on the same JTAG chain: this way, the JTAG software bridge can communicate with only a subset of the in-series TAPs. The \textbf{IDCODE} instruction allows returning the 32-bit identification code of the debugged SoC.

While \textbf{IDCODE} and \textbf{BYPASS} are generic instructions, TAPs all have instructions that are specific to the FPGA/target architecture. Such instruction codes can be found in the BSD (\textit{Boundary Scan Description}) files of the target architecture. Depending on the number of instructions available on the TAP, the size of the IR may vary. For instance, the Lattice ECP5 FPGA has an \textit{irlen} of 8, and instructions \textbf{ISC\_PROGRAM\_DONE} (\verb|0b01011110|) and \textbf{ISC\_ERASE} (\verb|0b00001110|) are used to reprogram the FPGA gates.

\begin{figure}
    \centering

\begin{CodeVerbatim}
-- Instruction register description
	attribute INSTRUCTION_LENGTH of LFE5U_85F_XXBG756 : entity is 8;
	attribute INSTRUCTION_OPCODE of LFE5U_85F_XXBG756 : entity is
		"              IDCODE		(11100000)," &
		"          ISC_ENABLE		(11000110)," &
		"    ISC_PROGRAM_DONE		(01011110)," &
[...]
		"           ISC_ERASE		(00001110)," &
		"            ISC_NOOP		(00110000)," &
		"              SAMPLE		(00011100)," &
		"               HIGHZ		(00011000)," &
		"              EXTEST		(00010101)," &
\end{CodeVerbatim}
    \caption{Lattice ECP5 BSD File Snippet}
    \label{fig:ecp5_bsd}
\end{figure}

\section{Lattice ECP5 FPGA}

\subsection{Gecko5Education}

%source: Antoine. either cite or modify

The \textit{Gecko5Education} board is an FPGA development platform primarily used for teaching digital systems and computer architecture at EPFL. It is designed to give students hands-on experience and features a \textbf{Lattice ECP5 FPGA} at its core. The board also includes various peripherals suitable for system-on-chip experimentation, such as DRAM memory blocks, General-Purpose I/Os (GPIOs) like push buttons and switches, an RGB LED matrix, and a UART interface for serial communication.

Although the board provides a JTAG port through a USB-C connector, it was previously unused due to its minimal implementation and both the availability and ease-of-use of UART for communication. Unlike CPUs, which execute software instructions sequentially, FPGAs are reconfigurable hardware platforms used to implement custom digital logic circuits. They are programmed using hardware description languages (HDLs); in this project, Verilog is used to describe the hardware’s structure and behavior. The HDL code is then synthesized, placed, and routed to produce a bitstream, which is loaded into the FPGA to configure its logic.


%hardware used to host the gecko5education in both courses

\subsection{The JTAGG Primitive}

The \textbf{JTAGG} \cite{lattice_ref_guide} component is the hardware implementation of the JTAG TAP Controller available on Lattice ECP5 FPGAs. When working on the Gecko5Education, the JTAGG TAP is used to reconfigure the FPGA logic using tools like \textit{openFPGALoader}.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{assets/jtagg_pins.png}
    \caption{JTAGG Primitive}
    \label{fig:jtagg_pins}
\end{figure}

For security, the JTAGG primitive does not provide direct access to the four main raw JTAG signals (\textit{TCK}, \textit{TMS}, \textit{TDI} and \textit{TDO}) and only provides access to signals presented in figure \ref{fig:jtagg_signals}. The JTAGG primitive provides two slots for user-defined instructions with respective opcodes \verb|0x32| and \verb|0x38|. In this project, we use opcode \verb|0x32| to interface with our internal debug controller component. Note that \textit{JRTI}\verb|x| and \textit{JCE}\verb|x| are only high when the corresponding user instruction is loaded into the IR. \verb|x| can be either 1 or 2.

\begin{figure}
    \centering

\begin{tabular}{|c|p{10cm}|}
\hline
\textbf{Signal} & \textbf{Description} \\
\hline
\textbf{JTDI} & Latched (one clock cycle late) TDI signal \\
\hline
\textbf{JTCK} & Same as TCK \\
\hline
\textbf{JRTIx} & Active high when TAP in Run-Test/Idle state \\
\hline
\textbf{JSHIFT} & Active high when TAP in Shift-DR \\
\hline
\textbf{JUPDATE} & Active high when TAP in Update-DR \\
\hline
\textbf{JRSTN} & Active low, async reset line \\
\hline
\textbf{JCEx} & Active high when TAP in Shift-DR or Capture-DR \\
\hline
\textbf{JTDOx} & User instruction output (TDO) \\
\hline
\end{tabular}

    \caption{JTAGG Synchronous Signals}
    \label{fig:jtagg_signals}
\end{figure}

\section{Advanced Debug System}

The \textit{Advanced Debug System} \cite{adv_debug_sys} project is an open-source soft-core available on OpenCores. It provides several components, including an \textbf{Advanced Debug Interface} (or "ADI"), which is the component between the JTAG controller and the soft-core SoC, as well as several implementations of \textbf{soft-core JTAG TAP controllers} such as \verb|xilinx|, \verb|mohor|, \verb|actel| or \verb|altera|. We discuss the structure of the ADI in the following chapter.

According to its documentation, the usual approach is to synthesize a soft-core TAP controller alongside the ADI and to use four FPGA physical pins to emulate a standard JTAG connection. The documentation also mentions the possibility of directly using the hardware JTAG controller already present on the FPGA—typically the one used for gate array reconfiguration—but this option is limited to devices that implement the UJTAG interface, such as those in the ProASIC family.

In this project, we take a slightly different approach: we directly leverage the native JTAG hardware controller available on our Lattice FPGA. As a result, the provided soft-core TAP implementations are used only as reference designs to guide the integration of the Advanced Debug Interface, rather than being instantiated in our final system. Furthermore, we make use of the reference soft-core implementation of the JTAGG primitive provided by Tom Verbeure \cite{verbeure} to help with our ADI refactor.

While using a soft-core TAP controller has the benefit of exposing all raw JTAG signals, using the hardware JTAG primitive of our FPGA along with the existing USB terminal avoids having to set up an additional USB terminal from scratch. In the following chapter, we discuss the modifications required to the ADI to adapt to this non-native TAP controller.

%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Implementation}
%%%%%%%%%%%%%%%%%%%%%%%%

\section{OpenOCD} 

\subsection{OpenOCD Driver}

In order to communicate with our debug controller, OpenOCD needs to know:
\begin{itemize}
    \item the DR register sizes (or \textit{DR length}) and command formats,
    \item the IR register size (or \textit{IR length}),
    \item the IR opcodes that correspond to our debug controller.
\end{itemize}

Since our processor is very similar to the OR1200 processor, in order to avoid having to implement both a software driver and a hardware debug controller entirely from scratch, we use one of the OR1200-ready debug interfaces supported by OpenOCD \cite{soc_debug_sys} \cite{adv_debug_sys}, namely the ADI (\textit{Advanced Debug Interface}). Consequently, the DR register sizes and command formats remain exactly the same, as they are embedded in the semantics of our ADI driver. The OpenOCD source file of our ADI driver is \verb|or1k_du_adv.c|, and no modification is required.

Since we are using the JTAGG hardware primitive of our Lattice FPGA, we have no choice but to use the JTAGG IR length, which is 8. This number is provided to OpenOCD inside the OpenOCD server config file through the \verb|-irlen| parameter (see figure \ref{fig:openocd_server_config}).

The IR opcodes depend on the TAP controller that we are communicating with. The ADI actually provides three different Verilog implementations of popular TAP controllers, including \textit{Mohor}, \textit{Xilinx} and \textit{Intel}. The user is free to choose which TAP controller to implement alongside the ADI. All of these TAP controllers are supported by the OpenOCD \textit{or1k} driver, and it is the responsibility of the user to specify in the OpenOCD server configuration file which TAP controller is being used by the ADI through the \verb|tap_select| command (see figure \ref{fig:openocd_server_config}). OpenOCD has three different JTAG TAP drivers, one for each of these controllers, all of them being mutually incompatible with one another. 

However, none of these drivers are compatible with the Lattice JTAGG primitive. Consequently, we need to write a new OpenOCD driver that will support it. Fortunately, the amount of changes required relative to the existing \textit{Mohor/OpenCores} TAP driver is very limited. We start with the \textit{Mohor/OpenCores} TAP driver (whose source file is \verb|or1k_tap_mohor.c|) and perform the following changes:
\begin{itemize}
    \item increase its IR length from \verb|4| to \verb|8|,
    \item change the IR opcode of the debug controller from \verb|0x8| to \verb|0x32| to match the first JTAGG user instruction code.
\end{itemize}

We compile OpenOCD along with this new driver of ID \verb|gecko|, stored in the \verb|or1k_tap_gecko.c| source file. This driver can be activated using the command \verb|tap_select gecko| inside an OpenOCD server configuration file (see figure \ref{fig:openocd_server_config}).

\subsection{Additional Notes}

Note that the native ADI driver has a small bug when a Wishbone bus error happens while performing a bus operation. Normally, if the driver observes a Wishbone bus error during its transaction, it should retry up to 3 times before giving up. The bug causes OpenOCD to loop and retry the memory operation forever (the user then has to manually kill the process). This bug is not very convenient when working on the BIU, as any mistake made with system bus protocol would often result in a bus error, causing OpenOCD to freeze. This bug has been fixed in the provided OpenOCD source.

OpenOCD also has a bug with legacy/hi-speed support, more information about this in section \ref{sec:hispeed_mode}.

\subsection{Server Config File}

In the OpenOCD server config presented in figure \ref{fig:openocd_server_config}, we provide the IDCODE and IR length of the Lattice FPGA TAP controller. Then, we associate this TAP controller to a big-endian \textit{or1k} target CPU. We select our TAP driver and debug unit interface. Recall that OpenOCD does support two debug interfaces \cite{soc_debug_sys} \cite{adv_debug_sys}, one being more recent and performant than its ancestor.

If we were to only register a "raw" TAP controller in OpenOCD, we could connect to the OpenOCD server and send raw JTAG commands through a Telnet client. By associating this TAP controller to an \textit{or1k} CPU, we tell OpenOCD to interpret this JTAG terminal as a debuggable CPU. As a result, it opens a GDB RSP server instead, that we can connect to using GDB.

\subsection{Connecting using Telnet or GDB}
\label{sec:gdb_command}

The following command can be used to open a Telnet connection to the OpenOCD server (running on port 4444) to send raw JTAG commands to the ADI:

\verb|telnet localhost 4444|

The following command can be used to open a connection to the GDB RSP server (running on port 3333) to debug the CPU using GDB.

\verb|or1k-elf-gdb hello.elf --eval-command='target remote localhost:3333'|

\begin{figure}
    \centering
\begin{CodeVerbatim}
set _CPUTAPID  0x41113043
set _ENDIAN big
set _TARGETNAME $_CHIPNAME.cpu
set _CHIPNAME or1k

jtag newtap $_CHIPNAME cpu \
    -irlen 8 -irmask 0x83 -ircapture 0x1 \ 
    -expected-id 0x41113043
target create $_TARGETNAME or1k \ 
    -endian $_ENDIAN \ 
    -chain-position $_TARGETNAME
tap_select gecko
du_select adv [expr {0}]
\end{CodeVerbatim}

    \caption{OpenOCD Server Config}
    \label{fig:openocd_server_config}
\end{figure}



\section{Top-Level Debug Controller}

The \verb|adv_debug_if| debug controller is composed of a top-level debug controller with four sub-modules (see figure \ref{fig:adv_debug_sys_scheme}): two sub-modules for the CPU cores, one sub-module for accessing the Wishbone system bus, and one sub-module for the JSP server. \textit{The JSP server sub-module is out of the scope of this project—it allows emulating a serial connection through our JTAG connection.}

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{assets/adv_debug_sys_scheme.png}
    \caption{ADI Global Structure (Source: \cite{adi_doc})}
    \label{fig:adv_debug_sys_scheme}
\end{figure}

The top-level debug controller receives 53-bit commands from the JTAG TAP. The MSB indicates if the JTAG command is directed to the top-level debug controller. There is only one type of command for the top level, namely sub-module selection. Since there are four sub-modules, we need two bits to uniquely identify all sub-modules. The \textbf{Wishbone} sub-module has ID \verb|0b00| while \textbf{CPU0} and \textbf{CPU1} sub-modules have IDs, respectively, \verb|0b01| and \verb|0b10|. Therefore, the sub-module selection command is only three bits long.

Even though the DR input register of the top-level ADI is 53 bits long, OpenOCD actually only needs to shift in 3 bits. When communicating with the top-level, the MSB is always set to 1, indicating a module selection command. This bit is followed by the 2 bits identifying the module to be selected. If the MSB is set to 0, then the command has to be 53 bits long exactly, and it will be dispatched to the currently selected submodule.

\subsection{TDI 1-Cycle Delay Problem}
\label{sec:tdi_pb}

In order to avoid long critical paths, the JTAGG primitive latches the input signal TDI, making the JTDI signal one cycle late. If no modification is done to the current implementation of the debug controller input shift register logic, the LSB of the JTAG command will be garbage, and the MSB will be lost.

In the previous semester project \cite{antoine} focusing on JTAG support for Gecko5Education, the solution proposed was to virtually increase by 1 bit all DR-scans sent to the JTAGG TAP controller. This has the effect of erasing the garbage LSB and loading in the MSB at the last moment in the input shift register. While this solution works, it is not applicable to our situation without major OpenOCD refactors. A hardware-side patch would be much more convenient as it would allow our debug controller to be compatible with the existing \textit{or1k} OpenOCD driver. 

To patch this, we delay the internal \verb|shift_dr_i| signal by one cycle. Recall that this signal indicates if the TAP is currently in state \textit{Shift-DR}, in which case the debug controller needs to shift its internal input shift register by one bit, while loading one bit from the TDI line and exposing the outgoing LSB to the TDO line. This patch has the effect of "waiting" for the relevant signal to be ready on the TDI line.

Fortunately, \textbf{there is exactly a 1-cycle time frame} between the last bit of payload sent through TDI and the time by which the TAP FSM enters the \textit{Update-DR} state. This is due to the fact that the TAP FSM needs two cycles with \textbf{TMS} set to \textbf{1} to exit the \textit{Shift-DR} state and enter the \textit{Update-DR} state. Since all internal register updates of the debug sub-modules happen on this last state, this leaves us exactly the amount of time needed to fix the content of the input shift register.


\section{System Bus Module}

The system bus sub-module, or \textit{Wishbone} module, with module ID \verb|2'b0|, is responsible for interfacing between the ADI and the system bus. Since the SDRAM controller is connected to the system bus, it is the module GDB uses to perform memory reads and writes.

When OpenOCD receives a memory read (or write) requested by the user through GDB, this memory read (or write) is interpreted as two distinct DR-scans. The first DR-scan is always a \textit{Burst Setup} command, and the second scan is always a \textit{Burst} command.

Intuitively, the first DR-scan provides the address to read from (or write to), the number of bytes to read (or write), and the word size. It is always of fixed size (53 bits), and its structure is presented in figure \ref{fig:burst_setup_fmt}. The \textit{Burst Setup} format is the same for reads and writes. The second DR-scan executes the memory read (or write) by either reading words from the Bus Interface Unit (BIU) and transferring them through the JTAG TDO line, or by shifting in bits from the TDI line and instructing the BIU to write full 32-bit words.

The BIU is the subcomponent of the Wishbone module responsible for interfacing with the SoC system bus. Since our SoC does not use the native ADI bus architecture (Wishbone), most of our work consists of refactoring the state machine of the BIU to match our SoC system bus architecture.

\subsection{Memory Read Example}

The corresponding \textit{Burst Setup} command for reading 4 bytes of memory from address \verb|0xABC| is the following. Note that according to the ADI documentation \cite{adi_doc}, opcode \verb|0x7 = 0b111| corresponds to a 32-bit read.

\verb|0b0_0111_00000000000000000000101010111100_0000000000000100|

After sending the \textit{Burst Setup} command, OpenOCD will perform a \textit{Burst Read} command by shifting in only 0's. The ADI does not care about the bits shifted in, as the only important part is the bits of payload shifted out through TDO. The format of \textit{Burst Read} commands is presented in figure \ref{fig:burst_read_fmt}. One status bit (see section \ref{sec:hispeed_mode}) indicates if the memory operation was performed successfully. For instance, it is unasserted if a bus error happened during the transaction, instructing OpenOCD to try the same transaction again. This status bit is followed by the data payload (32-bit words), followed by a 32-bit CRC code for error detection.

In case of a write, the \textit{Burst Setup} command is very similar. The opcode is now \verb|0x3| for 32-bit writes.

\verb|0b0_0011_00000000000000000000101010111100_0000000000000100|

The \textit{Burst Write} command format is presented in figure \ref{fig:burst_write_fmt}. This time, OpenOCD shifts in the 32-bit words that must be written to memory, potentially interleaved with status bits (see section \ref{sec:hispeed_mode}), followed by a 32-bit CRC. The last bit transferred is a \textit{match} bit, which the ADI uses to indicate to OpenOCD if the CRC transferred by OpenOCD matches the one computed in hardware by the ADI. In case of a CRC error, the transaction is aborted. OpenOCD listens to this \textit{match} bit as well as \textit{status} bits to make sure no bus error occurred during the transfer. 


\begin{figure}
    \centering


    \begin{subfigure}{0.8\linewidth}
        \centering
        \includegraphics[width=\linewidth]{assets/burst_setup_fmt.png}
        \caption{Burst Setup}
        \label{fig:burst_setup_fmt}
    \end{subfigure}
    
    \vspace{0.5cm}

\begin{subfigure}{0.8\linewidth}
        \centering
        \includegraphics[width=\linewidth]{assets/burst_read_fmt.png}
        \caption{Burst Read}
        \label{fig:burst_read_fmt}
    \end{subfigure}

    \vspace{0.5cm}

    \begin{subfigure}{0.8\linewidth}
        \centering
        \includegraphics[width=\linewidth]{assets/burst_write_fmt.png}
        \caption{Burst Write}
        \label{fig:burst_write_fmt}
    \end{subfigure}
    
    \caption{OpenOCD JTAG Command Formats (Source: \cite{adi_doc})}
    \label{fig:burst_cmd_fmts}
\end{figure}


\subsection{FSM Refactoring}

The FSM of the initial Wishbone BIU only has two states, \verb|IDLE| and \verb|TRANSFER|. In the \verb|IDLE| state, the BIU has either 1) never received any instruction from the Wishbone submodule, or 2) has successfully performed the required memory operation, and in case of a read, the read payload is available in internal register \verb|data_out_reg|, or 3) has performed the memory operation which resulted in an error, in which case the \verb|err_reg| internal register is asserted.

The Wishbone standard specifies two important signals that allow the BIU FSM to switch between states. \verb|wb_strobe_i| is asserted when a transaction starts: the FSM transitions from \verb|IDLE| to \verb|TRANSFER|. When \verb|wb_ack_i| is asserted, it indicates that the memory operation was successfully conducted, and the FSM can successfully transition back to \verb|IDLE|. In case of a Wishbone bus error, \verb|wb_err_i| is asserted.

The major difference in our new FSM is that the BIU now needs to wait for a grant from the bus arbiter. The system bus is used by multiple peripherals simultaneously, and access to the system bus is granted by a central bus arbiter. The major FSM change is the addition of a \verb|WAIT| state. The BIU transitions to this state when the Wishbone submodule instructs a new memory operation. It asserts a request signal, and waits for a grant from the arbiter. When obtaining this grant, it transitions to the \verb|TRANSFER| state. In case of a read, the BIU provides the memory address being read from and waits for the \verb|sb_data_valid_i| signal, which is the equivalent of the \verb|wb_ack_i| signal.

In case of a write, our system bus behaves slightly differently. The VP system bus has a \verb|sb_busy| signal that indicates that the bus slave has not been able to execute the memory write provided on the last clock cycle. Consequently, the FSM needs to stay in the \verb|TRANSFER| state until the first cycle where the busy bit is zero. On the first cycle where the busy bit is unasserted, our BIU transitions back to the \verb|IDLE| state. By design, the BIU is never busy, so the read operation is marked successful as soon as the \verb|data_valid| signal is asserted.



%\begin{figure}
%    \centering
%
%\begin{CodeVerbatim}
%uint32_t data[2];
%/* Set up the data */
%data[0] = length_words | (address << 16);
%/* MSB must be 0 to access modules */
%data[1] = ((address >> 16) | ((opcode & 0xf) << 16)) & ~(0x1 << 20);
%
%struct scan_field field;
%field.num_bits = 53; // number of bits
%field.out_value = (uint8_t *)&data[0];
%field.in_value = NULL; // ignore TDO
%\end{CodeVerbatim}
%
%    \caption{OpenOCD code for burst command}
%    \label{fig:placeholder}
%\end{figure}

%\begin{tabular}{>{\bfseries}l c c l}
%\toprule
%\textbf{Champ} & \textbf{Plage de bits} & \textbf{Taille (bits)} & \textbf{Description} \\
%\midrule
%module\_cmd       & [52]       & 1  & Sélection de module (\texttt{0} = accès module) \\
%operation\_in     & [51:48]    & 4  & Opcode de l'opération (lecture, écriture, burst, etc.) \\
%address\_data\_in & [47:16]    & 32 & Adresse mémoire de départ du transfert \\
%count\_data\_in   & [15:0]     & 16 & Nombre de mots à transférer (longueur du burst) \\
%\midrule
%\textbf{Total} & & \textbf{53} & \\
%\bottomrule
%\end{tabular}

\subsection{Hi-Speed Mode}
\label{sec:hispeed_mode}

This section discusses an issue encountered while refactoring the original ADI. The OR1200 ADI has two modes for memory burst commands: \textit{Legacy} and \textit{Hi-Speed} mode. In legacy mode, memory read/write bursts transfer an additional status bit for every word transferred over JTAG. In hi-speed mode, memory bursts only provide exactly one status bit at the beginning of the burst DR-scan.

The user can choose which mode to use by flipping a constant in the RTL specification of the ADI before synthesis. In any case, the option specified in the ADI RTL must match the option provided in the OpenOCD server configuration file, as it alters the JTAG command formats used.

The reason for this status bit is the following. Suppose we are performing a memory read from the system bus. Recall that the Wishbone BIU implements a basic "best-effort optimistic" protocol for reading from and writing to the system bus. For memory reads, for instance, while the bits of the previous 32-bit words are transferred through the JTAG line, the BIU requests access to the system bus, waits for a grant from the arbiter, and performs the next single 32-bit word read as soon as bus grant is provided.

In other words, if the system bus is heavily congested, the BIU may not have completed the next 32-bit read by the time the Wishbone top-level module expects to shift out valid data. This is precisely why status bits are included in the returned data. Each status bit is set to 1 if the BIU was ready—that is, if the corresponding single-word read on the system bus actually took place. Conversely, if the status bit is 0, it indicates that the BIU had not yet completed the read, and therefore the bits shifted out during that cycle must be considered garbage.

The \textit{or1k} OpenOCD driver is aware of these status bits, and will retry the full memory read until all status bits are set to 1, up to a user-defined threshold.

Most of the time, the SoC bus clock (in our case, synchronous) is much faster than the JTAG clock, which makes the JTAG TDI/TDO line the bottleneck of our JTAG data transmission. In our case, the JTAG controller operates at ~4 MHz while the SoC operates at almost ~80 MHz. If we only perform 32-bit words, this leaves the BIU \verb|32 * 80 / 4 = 640| bus cycles to perform the next word read. For this reason, Hi-speed mode just optimistically presumes that the BIU never fails to execute bus transactions in time.

That being said, while the OpenOCD documentation explicitly states the possibility of disabling Hi-speed mode through the use of a config file option, the source code of the ADI driver never modifies the number of bits sent through JTAG depending on the option chosen. \textbf{It seems like the OpenOCD ADI driver is hard-coded to Hi-speed mode.}

While I planned to use Legacy mode for debugging (primarily for making sure that the system bus was executing bus operations fast enough), I was eventually forced into switching to Hi-speed mode for prototyping as it seemed like Legacy mode was simply not supported at all.

\section{CPU Module}

The CPU submodule of the ADI is responsible for reading and writing to the CPU register file, step-by-step execution, and handling of program breakpoints.

\subsection{Register Read and Writes}

The CPU submodule is structurally very similar to the Wishbone submodule, as presented in figure \ref{fig:adv_debug_sys_scheme}. It contains FSM logic, internal registers (see next section), as well as a CRC and a BIU. The BIU is the same as the Wishbone BIU, the only difference is that the Wishbone submodule communicates with the system bus, while the CPU submodule BIU communicates with the register file.

\subsection{Future Work}

While step-by-step execution and program breakpoint management were in the scope of this project, I did not have time to start working on these real-time debugging features.

All ADI submodules (CPU, Wishbone, JSP) have internal module registers that can be read from or written to. The CPU submodule contains a single internal register, the \textit{status register}, which is a 2-bit register. One of these bits indicates whether or not the CPU is currently stalled. Writing to this internal register stalls the CPU. Internal register reads and writes consist of two distinct DR scans. The first DR scan is a \textit{Register Select} command as presented in figure \ref{fig:reg_sel_fmt}. The second DR scan is similar to a burst read. OpenOCD needs to shift in at least as many bits as the size of the internal register. The bits shifted out by the ADI correspond to the current internal register content.

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{assets/reg_sel.png}
    \caption{\textit{Register Select} Command (opcode must be set to \textbf{0xD})}
    \label{fig:reg_sel_fmt}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%

\section{Real-Time Tests}

\subsection{Sub-Module Selection}

To test sub-module selection command, we display the ID of the selected module on the RGB LED array of the Lattice FPGA.

We use a Telnet connection to connect to OpenOCD, and send DR-scans of length 3 to select a module. The module ID is stored in an internal register called \verb|module_id_reg|. The commands \verb|irscan ecp5.tap 0x32| followed by \verb|drscan ecp5.tap 3 0b110| select the \textbf{CPU1} submodule. The second leftmost LED lights up when \verb|module_id_reg // 2 == 1|, the leftmost lights up when \verb|module_id_reg % 2 == 0|.

This simple test allows us to properly test our interfacing with the JTAGG component and make sure that the 1-cycle-late-TDI problem is properly patched.

\subsection{Register Reads}

While register reads and writes were not implemented in this project, we can still validate the JTAG and ADI integration by trying to read "dummy" values from the register file. This can be done very easily by hard-coding the \verb|rdy_o| signal to \verb|high|, and the \verb|data_out_reg| signal to a dummy value like \verb|0xDEADBEEF|. This tricks the CPU submodule into thinking the BIU has successfully performed its last instructed memory read.

The GDB command \verb|p/x <register>| can be used to display the content of a general-purpose register from the \textit{or1k} register file. The output is the following, which confirms that 1) the top-level debug controller successfully received and dispatched the read command to the CPU submodule and 2) the CPU submodule read data from its BIU.

\begin{CodeVerbatim}
(gdb) p/x $r2
$3 = 0xdeadbeef
\end{CodeVerbatim}

Note that after performing at least one memory operation, OpenOCD cycles indefinitely through the CPU and Wishbone modules. I believe this is due to OpenOCD trying to stall the CPU for step-by-step execution, but since this has not been implemented yet, OpenOCD keeps trying indefinitely.

\begin{CodeVerbatim}
Debug: 409 11536 or1k_du_adv.c:263 adbg_select_module(): Select module: CPU0
Debug: 410 11537 or1k_du_adv.c:263 adbg_select_module(): Select module: WISHBONE
Debug: 411 11636 or1k_du_adv.c:263 adbg_select_module(): Select module: CPU0
Debug: 412 11637 or1k_du_adv.c:263 adbg_select_module(): Select module: WISHBONE
....
\end{CodeVerbatim}


\subsection{Memory Reads}

The GDB command \verb|x/wx <address>| can be used to read a 32-bit word at a given address in memory. The resulting OpenOCD debug logs are shown in figure \ref{fig:mem_read_output} for 32-bit aligned and unaligned reads.

The top figure presents a 4-byte aligned 32-bit (full word) memory read. Since it is aligned, it is properly interpreted as a single burst read on the bus. On the bottom figure however, we can see than the OpenOCD \textit{or1k} driver splits up an unaligned 32-bit read into three distinct reads: two 1-byte reads at \verb|0x401| and \verb|0x404| with \verb|byte_enables| masks of \verb|0b0100| and \verb|0b1000| respectively, and one 2-byte read at \verb|0x402| with mask \verb|0b0011|.

This is done accordingly to the memory alignment specifications provided in the OR 1000 architecture manual \cite{or1000_arch_manual}. Indeed, the 32-bit OR 1000 architecture does not support unaligned 4-byte (full word) reads.

\begin{figure}

    \begin{subfigure}[t]{\textwidth}
        \begin{CodeVerbatim}
Debug: 361 [or1k.cpu] {1} received packet: m400,4
Debug: 362 addr: 0x0000000000000400, len: 0x00000004
Debug: 363 reading buffer of 4 byte at 0x00000400
Debug: 364 Read memory at 0x00000400, size: 4, count: 0x00000001
Debug: 365 Reading WB32 at 0x00000400
Debug: 366 Select module: WISHBONE
Debug: 367 Doing burst read, word size 4, word count 1, start address 0x00000400
Debug: 370 CRC OK!
Debug: 372 [or1k.cpu] {1} sending packet: $a2aa2aae#ae
        \end{CodeVerbatim}
        \caption{Aligned 32-bit Memory Read}
        \label{fig:mem_read_a}
    \end{subfigure}
    
    \vspace{0.5cm}

    \begin{subfigure}[t]{\textwidth}
\begin{CodeVerbatim}
Debug: 1284 [or1k.cpu] {1} received packet: m401,4
Debug: 1285 addr: 0x0000000000000401, len: 0x00000004
Debug: 1286 reading buffer of 4 byte at 0x00000401
Debug: 1287 Read memory at 0x00000401, size: 1, count: 0x00000001
Debug: 1288 Reading WB8 at 0x00000401
Debug: 1289 Doing burst read, word size 1, word count 1, start address 0x00000401
Debug: 1292 CRC OK!
Debug: 1294 Read memory at 0x00000402, size: 2, count: 0x00000001
Debug: 1295 Reading WB16 at 0x00000402
Debug: 1296 Doing burst read, word size 2, word count 1, start address 0x00000402
Debug: 1299 CRC OK!
Debug: 1301 Read memory at 0x00000404, size: 1, count: 0x00000001
Debug: 1302 Reading WB8 at 0x00000404
Debug: 1303 Doing burst read, word size 1, word count 1, start address 0x00000404
Debug: 1306 CRC OK!
Debug: 1308 [or1k.cpu] {1} sending packet: $44004546#9b
        \end{CodeVerbatim}
        \caption{Unaligned 32-bit Memory Read}
        \label{fig:mem_read_output_unaligned}
    \end{subfigure}

    \caption{Memory Reads}
    \label{fig:mem_read_output}
\end{figure}



\subsection{Memory Writes}

The GDB command \verb|set {int}0x<address> = <value>| can be used to write a 32-bit word value to a specific address in memory. The output of such command is provided on figure \ref{fig:write_bug}.

At the moment, memory writes still suffer from CRC errors. A plausible cause is the reoccurrence of the issue described in \ref{sec:tdi_pb}. While this issue was fixed for the top-level input register, the Wishbone submodule and its own CRC submodule still utilize this input line.

Testbenches do reproduce this issue, as the data stored in the \verb|data_in_reg| (internal register that stores data to be written to the system bus) does not match the data written by OpenOCD. Then, since the CRC module inputs utilize the TDI input line, these need to be refactored too. The testbench provided does not actually check the CRC or data provided back to OpenOCD through the TDO line.

\textit{Burst Setups} function correctly because they are first stored in the top-level input shift register (where TDI timing is corrected), then forwarded to the corresponding submodule. \textit{Burst Reads} function properly as they do not utilize the TDI input line, unlike \textit{Burst Writes} which use the TDI line to read data payload and compute CRC.

\begin{figure}
    \centering
\begin{CodeVerbatim}
Debug: 356 addr: 0x400, len: 0x00000004
Debug: 357 writing buffer of 4 byte at 0x00000400
Debug: 358 Write memory at 0x00000400, size: 4, count: 0x00000001
Debug: 359 Writing WB32 at 0x00000400
Debug: 360 Select module: WISHBONE
Debug: 361 Doing burst write, word size 4, word count 1,start address 0x00000400
Warn : 362 CRC ERROR! match bit after write is 0 (computed CRC 0xe5a59fe0)
Warn : 363 CRC ERROR! match bit after write is 0 (computed CRC 0xe5a59fe0)
Warn : 364 CRC ERROR! match bit after write is 0 (computed CRC 0xe5a59fe0)
Debug: 365 Reporting -4 to GDB as generic error
Debug: 366 [or1k.cpu] {1} sending packet: $E0E#ba
\end{CodeVerbatim}
    \caption{Writing a full word to memory}
    \label{fig:write_bug}
\end{figure}


\section{Testbenches}

Testbenches are provided to test both top-level module selection and memory operations. These testbenches are stored in the folder \verb|src/vp/modules/jtag/test|. The following testbenches are provided:
\begin{itemize}
    \item \verb|./tb_select_module.sh| to test top-level submodule selection
    \item \verb|./tb_mem_read.sh| to test Wishbone read/writes.
\end{itemize}

\section{Benchmarks}

\subsection{Upload Speed}

One key feature of GDB coupled with a debug interface is the ability to upload programs to the target platform. Currently, in order to upload a program to the virtual prototype, we need to use a Serial graphical interface such as CuteCom to write the program directly into RAM over a serial UART connection. As Serial UART connections are known to be particularly slow, we would like to use JTAG instead to benefit from higher upload speeds. The \verb|load| GDB command can be used to upload the provided program to the target RAM. The program to be uploaded is the one provided in the GDB run command (see section \ref{sec:gdb_command}).

Figure \ref{fig:uploading_prog_theoret} shows the output of a \verb|load| command with CRC checks commented out in OpenOCD. Due to a bug in the current implementation of the debug interface, writes do not work yet (and yield CRC errors). However, it is safe to assume that disabling CRC checks has very limited influence on software overhead (and therefore benchmark results). Program upload speed depends on the JTAG clock, ADI mode (hi-speed or legacy), bus availability, and OpenOCD software overhead.

Using GDB and the debug interface for uploading programs, with a JTAG clock of 4MHz, we achieve \textbf{a program upload speed of 420KB/s}. We can compare this value to our Serial connection with baud rate 115200, which translates to at most 15KB/s with no overhead. The same "Hello World" program takes $<0.1$s to upload using GDB and $\approx 1.8s$ to upload using CuteCom.

Note that it is not particularly useful to further crank up the JTAG clock speed, as upload latencies are already very limited, and because our BIU optimistic design assumes that our system bus is always available on time. Increasing the JTAG clock could break this assumption and lead to OpenOCD having to try memory writes again.

\begin{figure}
    \centering
    \begin{CodeVerbatim}
(gdb) load
Loading section .vectors, size 0x184 lma 0x0
Loading section .text, size 0x200c lma 0x184
Loading section .rodata, size 0x16c lma 0x2190
Loading section .eh_frame, size 0x54 lma 0x22fc
Start address 0x00000100, load size 9040
Transfer rate: 420 KB/sec, 2260 bytes/write.
    \end{CodeVerbatim}
    \caption{Uploading a program through GDB (4MHz JTAG)}
    \label{fig:uploading_prog_theoret}
\end{figure}

% add benchmarks if time allows

%%%%%%%%%%%%%%%%%%%%%%
\chapter{Future Work}
%%%%%%%%%%%%%%%%%%%%%%

While the current implementation provides a foundation for real-time debugging of our \textit{or1k} CPU, several aspects remain to be addressed to achieve full feature completeness.

Regarding memory accesses, the Bus Interface Unit (BIU) was refactored to ensure compatibility with the system bus of the virtual prototype. The lack of bus errors and matching CRC codes for reads indicate that the top-level ADI and JTAG were successfully interfaced. At the moment, writes still produce CRC errors due to a mishandling of the TDI input line inside the Wishbone module. Future work should focus on fixing the Wishbone module and validate program uploading.

Second, GPR access through the debug interface is not yet fully supported. The BIU within the CPU submodule must still be adapted to connect to the register file. The register file is currently implemented as a simple dual-port memory, with both ports already allocated to the CPU decode stage. One possible solution would be to duplicate the register file in order to provide additional read ports dedicated to debugging purposes.

Finally, advanced debugging features such as single-step execution and breakpoint management have not yet been implemented. These mechanisms require tight integration with the CPU control logic and pipeline stages, and represent a natural continuation of this work.


%%%%%%%%%%%%%%%%%%%%
\chapter{Conclusion}
%%%%%%%%%%%%%%%%%%%%

Given its similarity to the OR1200 CPU, it is possible to implement real-time debugging for our soft-core CPU with limited modifications to our CPU, the \textit{Advanced Debug Interface}, and OpenOCD drivers. While this work focuses on refactoring the BIUs of the CPU and Wishbone modules to adapt them to the virtual prototype SDRAM and register file, some refactoring work is still needed inside the ADI source code to fully support step-by-step execution, register content access, and program breakpoint support.

%In the conclusion you repeat the main result and finalize the discussion of
%your project. Mention the core results and why as well as how your system
%advances the status quo.

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{References}
\nocite{*}
\printbibliography

% Appendices are optional
% \appendix
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \chapter{How to make a transmogrifier}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% In case you ever need an (optional) appendix.
%
% You need the following items:
% \begin{itemize}
% \item A box
% \item Crayons
% \item A self-aware 5-year old
% \end{itemize}

\end{document}
